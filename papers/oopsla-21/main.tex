%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[acmsmall, anonymous]{acmart}

% ----------------------------------------

%% Packages

\usepackage{xcolor}
\usepackage{color}
\usepackage{multicol}
\usepackage[ruled,vlined,noend]{algorithm2e}
\usepackage{xspace}
\usepackage{tikz}
\usepackage{tikzscale}
\usepackage{pgfplots}
\usepackage{paralist}
\pgfplotsset{compat=1.3}

\makeatletter
\patchcmd{\@verbatim}
  {\verbatim@font}
  {\verbatim@font\footnotesize}
  {}{}
\makeatother

\let\oldv\verbatim
\let\oldendv\endverbatim

\def\verbatim{\par\setbox0\vbox\bgroup\oldv}
\def\endverbatim{\oldendv\egroup\fboxsep0pt \noindent\colorbox[gray]{0.95}{\usebox0}\par}

% ----------------------------------------

%% Rights management information. This information is sent to you when you
%% complete the rights form. These commands have SAMPLE values in them; it is
%% your responsibility as an author to replace the commands and values with
%% those provided to you when you complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2021}
\acmYear{2021}
%% \acmDOI{10.1145/1122445.1122456}

%% These commands are for a JOURNAL article.
\acmConference[OOPSLA '21]{OOPSLA '21: ACM SIGPLAN conference on Systems,
  Programming, Languages, and Applications}{October 17--22 2021}{Chicago, IL}

%% \acmJournal{JACM}
%% \acmVolume{37}
%% \acmNumber{4}
%% \acmArticle{111}
%% \acmMonth{8}

%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
\citestyle{acmauthoryear}

% ----------------------------------------
%% Macros

\newcommand{\quickcheck}{\textit{QuickCheck}\xspace}
\newcommand{\quickchick}{\textit{QuickChick}\xspace}
\newcommand{\fuzzchick}{\textit{FuzzChick}\xspace}
\newcommand{\mutagen}{\textsc{Mutagen}\xspace}

% ----------------------------------------

%% end of the preamble, start of the body of the document source.

\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{\mutagen: Working title}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.

\author{Agust\'in Mista}
\email{mista@chalmers.se}
\affiliation{%
  \institution{Chalmers University of Technology}
  \city{Gothenburg}
  \country{Sweden}
}

\author{Alejandro Russo}
\email{russo@chalmers.se}
\affiliation{%
  \institution{Chalmers University of Technology}
  \city{Gothenburg}
  \country{Sweden}
}

%% By default, the full list of authors will be used in the page headers. Often,
%% this list is too long, and will overlap other information printed in the page
%% headers. This command allows the author to define a more concise list of
%% authors' names for this purpose.

%% \renewcommand{\shortauthors}{Mista and Russo}


% ----------------------------------------
%% The abstract is a short summary of the work to be presented in the article.

\begin{abstract}
  Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec facilisis
  facilisis, est dui fermentum leo, quis tempor ligula erat quis odio. Nunc
  porta vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum. Aliquam
  posuere. Nunc aliquet, augue nec adipiscing interdum, lacus tellus malesuada
  massa, quis varius mi purus non odio. Pellentesque condimentum, magna ut
  suscipit hendrerit, ipsum augue ornare nulla, non luctus diam neque sit amet
  urna. Curabitur vulputate vestibulum lorem. Fusce sagittis, libero non
  molestie mollis, magna orci ultrices dolor, at vulputate neque nulla lacinia
  eros. Sed id ligula quis est convallis tempor. Curabitur lacinia pulvinar
  nibh. Nam a sapien.
\end{abstract}

% ----------------------------------------

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm. Please
%% copy and paste the code instead of the example below.
\begin{CCSXML}
% CCS XML here
\end{CCSXML}

%% \ccsdesc[500]{Computer systems organization~Embedded systems}
%% \ccsdesc[300]{Computer systems organization~Redundancy}
%% \ccsdesc{Computer systems organization~Robotics}
%% \ccsdesc[100]{Networks~Network reliability}

% ----------------------------------------

%% Keywords. The author(s) should pick words that accurately describe the work
%% being presented. Separate the keywords with commas.
\keywords{random testing, mutations, heuristics}

% ----------------------------------------

%% This command processes the author and affiliation and title information and
%% builds the first part of the formatted document.
\maketitle

% ----------------------------------------

\section{Introduction}
\label{sec:intro}

Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec facilisis
facilisis, est dui fermentum leo, quis tempor ligula erat quis odio. Nunc porta
vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum. Aliquam posuere.
Nunc aliquet, augue nec adipiscing interdum, lacus tellus malesuada massa, quis
varius mi purus non odio. Pellentesque condimentum, magna ut suscipit hendrerit,
ipsum augue ornare nulla, non luctus diam neque sit amet urna. Curabitur
vulputate vestibulum lorem. Fusce sagittis, libero non molestie mollis, magna
orci ultrices dolor, at vulputate neque nulla lacinia eros. Sed id ligula quis
est convallis tempor. Curabitur lacinia pulvinar nibh. Nam a sapien.

The contributions of this work are:

\begin{itemize}
\item Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec
  facilisis facilisis, est dui fermentum leo, quis tempor ligula erat quis odio.
  Nunc porta vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum.
  Aliquam posuere. Nunc aliquet, augue nec adipiscing interdum, lacus tellus
  malesuada massa, quis varius mi purus non odio.
\item Pellentesque condimentum,
  magna ut suscipit hendrerit, ipsum augue ornare nulla, non luctus diam neque
  sit amet urna. Curabitur vulputate vestibulum lorem. Fusce sagittis, libero
  non molestie mollis, magna orci ultrices dolor, at vulputate neque nulla
  lacinia eros. Sed id ligula quis est convallis tempor. Curabitur lacinia
  pulvinar nibh. Nam a sapien.
\item Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec
  facilisis facilisis, est dui fermentum leo, quis tempor ligula erat quis odio.
  Nunc porta vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum.
  Aliquam posuere. Nunc aliquet, augue nec adipiscing interdum, lacus tellus
  malesuada massa, quis varius mi purus non odio.
\item Pellentesque condimentum, magna ut suscipit hendrerit, ipsum augue ornare
  nulla, non luctus diam neque sit amet urna. Curabitur vulputate vestibulum
  lorem. Fusce sagittis, libero non molestie mollis, magna orci ultrices dolor,
  at vulputate neque nulla lacinia eros. Sed id ligula quis est convallis
  tempor. Curabitur lacinia pulvinar nibh. Nam a sapien.
\end{itemize}


\section{Background}
\label{sec:background}

In this section we briefly introduce the concept of Property-based Testing along
with \quickcheck, the most popular tool of this sort and often considered as the
baseline when comparing PBT algoritms.
%
Moreover, we describe the ideas and limitations behind \fuzzchick, which
enhances the PBT approach with execution information and serves as the
foundation for \mutagen.
%
\fuzzchick is implemented as an extension of \quickchick, Coq's own
reimplementation of \quickcheck.

\subsection{Property-Based Testing and \quickcheck}

Property-based testing is a powerful technique for finding bugs without having
to write test cases by hand.
%
Originally introduced by \citet{quickcheck} in tandem with the first version of
\quickcheck, this technique focuses on aiming the developer's efforts into
testing systems via executable specifications using randomly generated inputs.
%
Moreover, tools like \quickchick and Isabelle's \quickcheck demonstrate
that PBT can also be used in the formal verification realm.
%
There, one can quickly spot bugs in system specifications before directing the
efforts into pointlessly trying to prove bogus propositions.


In the simplest form, there are four main elements the user needs to provide in
order to perform property-based testing on their systems:
%
\begin{itemize}
\item one or more \emph{executable properties}, often implemented simply as a
  boolean predicates,
\item \emph{random data generators}, used to repeatedly instantiate the testing
  properties,
\item \emph{printers}, used to show the user the random inputs that falsify some
  testing property (the counterexample) whenever a bug is found, and
\item \emph{shrinkers}, to minimize counterexamples making them easier to
  understand by humans.
\end{itemize}

\noindent In this work we focus solely on the first two elements introduced
above, namely the testing properties and the random data generators used to feed
them.
%
Printers and shrinkers, for the most part, can be obtained automatically using
generic programming capabilities present in the compiler, and although being
crucial for the testing process as a whole, their role becomes irrelevant when
it comes to \emph{finding} bugs.

\begin{algorithm}[ b]
  \SetKw{KwNot}{not}
  \SetAlgoLined
  \DontPrintSemicolon
  \SetKwFunction{QC}{Loop}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\QC{P, N, gen}}{
    i $\gets$ 0\;
    \While{i $<$ N}{
      x $\gets$ Sample(gen)\;
      \lIf{\KwNot P(x)}{\KwRet Bug(x)}
      i $\gets$ i+1 \;
    }
    \KwRet Ok\;
  }
\caption{\label{algo:quickcheck}\quickcheck Testing Loop}
\end{algorithm}

Perhaps the simplest PBT technique is to repeatedly generate random inputs and
instantiate the testing properties until they either get falsified by a
counterexample, or we ran a sufficiently large amount of tests --- suggesting
that the properties holds.
%
\quickcheck implements a testing loop that closely follows this simple idea,
which is outlined in Algorithm \ref{algo:quickcheck}, where $P$ is the testing
property, $N$ is the maximum number of tests to perform, and $gen$ is the random
generator to be used to instantiate $P$.


To illustrate this technique, let us focus on the same motivating example used
by \citeauthor{lampropoulos2019coverage}, who propose a simple property defined over
binary trees.
%
Such data structure can be easily defined in Haskell using a custom data type
with two data constructors for leaves and branches respectively:

\begin{verbatim}
data Tree a = Leaf a | Branch (Tree a) a (Tree a)
\end{verbatim}

\noindent The type parameter \texttt{a} indicates that trees can be instantiated
using any other type as payload, so the value \texttt{Leaf Bool} has type
\texttt{Tree Bool}, whereas the value \texttt{Branch (Leaf 1) 2 (Leaf 3)} has
type \texttt{Tree Int}.
%
Then, we can define tree reflections using a simple recursive function that
pattern matches against the two possible constructors, inverting the order of
the subtrees whenever it encounters a branch:

\begin{verbatim}
mirror :: Tree a -> Tree a
mirror (Leaf x)       = Leaf x
mirror (Branch l x r) = Branch (mirror r) x (mirror l)
\end{verbatim}

Later, a reasonable requirement to assert for is that \texttt{mirror} must be
\emph{involutive}, i.e., reflecting a tree twice always yields the original
tree.
%
We can simply capture this property using a boolean predicate written as a
normal function:

\begin{verbatim}
prop_mirror :: Tree Int -> Bool
prop_mirror t = mirror (mirror t) == t
\end{verbatim}

\noindent For simplicity, here we instantiate the tree payload with integers,
altough this predicate should clearly hold for any other type with a properly
defined notion of equality as well.


With our simple specification in place, the last missing piece is a random
generator of trees.
%
In \quickcheck, this is usually done via the type class mechanism, instantiating
the \texttt{Arbitrary} type class, providing a random generator as the
implementation of the overloaded \texttt{arbitrary} operation:

\begin{verbatim}
instance Arbitrary a => Arbitrary (Tree a) where
  arbitrary = sized gen
    where
      gen 0 = do { x <- arbitrary; return (Leaf x) }
      gen n = oneof [ do {x <- arbitrary; return (Leaf x) }
                    , do {l <- gen (n-1); x <- arbitrary; r <- gen (n-1); return (Branch l x r)} ]
\end{verbatim}

\noindent Let us break this definition into parts.
%
The first line states that we will provide an \texttt{Arbitrary} instance for
trees with payload of type \texttt{a}, provided that values of type \texttt{a}
can also be randomly generated.
%
This allows us to use \texttt{arbitrary} to generate \texttt{a}'s inside the
definition of our tree generator.


Moreover, \quickcheck internally keeps track of the \emph{maximum generation
  size}, a parameter that can be tuned by the user in order to limit the size of
the randomly generated values.
%
Our definition exposes this internal parameter via \quickcheck's \texttt{sized}
combinator, allowing us to parameterize the maximum size of the randomly
generated trees.
%
If the generation size is zero (\texttt{gen 0}), our generator is limited to
produce just leaves with randomly generated payloads.
%
In turn, when the generation size is strictly positive (\texttt{gen n}), the
generator is able to perform a random uniform choice between generating either a
single leaf or a branch.
%
When generating branches, the generator calls itself recursively in order to
produce random subtrees (\texttt{gen (n-1)}).
%
Notice the importance of reducing the generation size on each recursive call.
%
This way we ensure that randomly generated trees using a generation size
\texttt{n} are always finite and have at most \texttt{n} levels.

Finally, we are ready to let \quickcheck test \texttt{prop\_mirror} against a
large number of inputs (100 by default) produced by our brand new random tree
generator:

\begin{verbatim}
quickCheck prop_mirror
+++ Ok ####
\end{verbatim}

\noindent Should we mistakenly implement \texttt{mirror}, e.g., by dropping the
right subtree altogether:

\begin{verbatim}
mirror (Branch l x r) = Branch (mirror l) x (mirror l)
\end{verbatim}

\noindent then \quickcheck will quickly falsify \texttt{prop\_mirror}, reporting
a minimized counterexample that we can use to find the root of the issue:

\begin{verbatim}
quickCheck prop_mirror
*** Failed ####
\end{verbatim}

At this point, it is clear that the \emph{quality} of our random generators is
paramount to the performance of the overall PBT process.
%
Random generators that rarely produce interesting values will fail to trigger
bugs in our code, potentially leaving entire parts of the codebase virtually
untested.


Recalling our tree generator, the reader (far from mistaken) might already have
imagined better ways for implementing it.
%
For most practical purposes, this generator is in fact quite bad.
%
However, it follows a simple type-directed fashion, and it is a good example of
what to expect from a random generator synthesized automatically using a process
that knows very little about the values to be generated apart from their
(syntactic) data type structure.

As introduced earlier, there exist multiple tools that can automatically derive
better random generators solely from the static information present in the
codebase.
%
%% Such tools vary on the degree of invariants and requirements
%% %
%% However, such approaches are unable to derive useful generators whenever the
%% target data involves complex invariants that cannot be easily extracted from the
%% codebase or that cannot be easily expressed in terms of inductive relations.
%
Sadly, these tools lack the domain knowledge required to generate random data
with complex invariants --- especially those present in programming languages
like well-scopedness and well-typedeness.


In particular, automatically derived generators are remarkably uneffective when
used to test properties with sparse preconditions.
%
Let us continue with the example by \citeauthor{lampropoulos2019coverage} to
illustrate this problem in more detail.
%
For this, consider that we want to use our \texttt{Tree} data type to encode
binary-search trees (BST).
%
Then, given a predicate \texttt{isBST} that asserts if a tree satisfies the BST
invariants, we might want to use it as pre- and post-condition to assert that
BST operations like \texttt{insert} preserve them:

\begin{verbatim}
prop_bst_insert :: Tree a -> a -> Bool
prop_bst_insert t a =
  isBST t ==> isBST (insert a t)
\end{verbatim}

\noindent Attempting to test this property using \quickcheck does not work well:

\begin{verbatim}
quickCheck prop_bst_insert
*** Gave up! ####
\end{verbatim}

\noindent Here, \quickcheck discards random inputs as soon as it finds they do
not pass the precondition (\texttt{isBST t}).
%
Sadly, most of the inputs generated by our na\"ive generator suffer from this
problem, and the interesting part of the property (\texttt{isBST (insert a t)})
is tested very sporadically as a result.


At this point it is reasonable to think that, to obtain the best results when
using PBT over complex systems, one is forced to put a large amount of time on
developing manually-written generators.
%
In practice, that is most often the case, no automatic effort can beat a
well-thought manually-written generator that produces interesting complex values
and finds bugs in very few tests.
%
Not all is lost, however.
%
It is still possible to obtain acceptable results automatically by incorporating
dynamic information from the system under test into the testing loop.
%
The next subsection introduces the clever technique used by \fuzzchick to find
bugs in complex systems while using simple automatically derived random
generators.

%% Far from trying to compete against manual-efforts, our work focuses on improving
%% automatic approaches so they can be used paliatively in earlier development
%% stages.

\subsection{Coverage-Guided Property-Based Testing with \fuzzchick}

To alleviate the problem of testing properties with sparse preconditions while
using simple automatically derived random generators, \fuzzchick introduces
\emph{coverage-guided property-based testing} (CGPT) by enhancing the testing
process with two key characteristics:
%
\begin{inparaenum}
\item \emph{target code instrumentation}, to capture execution information from
  each test case; and
\item \emph{high-level, well-typed mutations}, to produce syntactically valid
  test cases by altering existing ones at the datatype level.
\end{inparaenum}

Using code instrumentation in tandem with mutations is a well-known technique in
the fuzzing community.
%
Generic fuzzing tools like AFL, libFuzzer or HonggFuzz, as well as
language-specific ones like Crowbar use execution traces to recognize
interesting test cases, e.g, those that exercise previously undiscovered parts
of the target code.
%
Later, such tools use generic mutators to combine and produce new test cases
from previously executed interesting ones.
%
\fuzzchick, however, does this in a clever way.
%
Instead of mutating any previously executed test case that discovers a new part
of the code, \fuzzchick integrates these fuzzing techniques into the PBT testing
loop itself.


Since it is possible to distinguish semantically valid test cases from invalid
ones, i.e., those passing the sparse preconditions of our testing properties as
opossed to those that are discarded early, \fuzzchick exploits this information
in order to focus the testing efforts into mutating valid test cases with a
higher priority than those that were discarded.


In addition, high-level mutators are better suited for producing syntactically
valid mutants, avoiding the time wasted by using generic low-level mutators that
act at the ``serialized'' level and know very little about the structure of the
generated data, thus producing syntactically broken mutants most of the time.
%
This grammar-aware mutation technique has shown to be quite useful when fuzzing
systems accepting structurally complex inputs.
%
Tools like Criterion, XSmith and LangFuzz use existing grammars to tailor the
generic mutators to the specific input structure used by the system under test.
%
In \fuzzchick, external grammars are not required.
%
The datatypes used by the inputs of the testing properties already describe the
structure of the random data we want to mutate in a concrete manner, and
specialized mutators acting at the data constructor level can be automatically
derived directly from their definition.

The next subsections describe \fuzzchick's testing loop and well-typed mutations
in detail.

\subsubsection{Testing loop}

Outlined in Algorithm \ref{algo:fuzzchick:loop}, the process starts by creating
two queues, \textit{QSucc} and \textit{QDisc} for valid and discarded previously
executed test cases, respectively.
%
Enqueued values are stored along with a given mutation energy, that controls how
many times a given test case can be mutated before being finally discared.


Once inside of the main loop, \fuzzchick picks the next test case using a simple
criterion: if there are valid values enqueued for mutation, it picks the first
one, mutates it and returns it, decreasing its energy by one.
%
If \textit{QSucc} is empty, then the same is attempted using \textit{QDisc}.
%
If none of the mutation queues contain any candidates, \fuzzchick generates a
new value from scratch.
%
This selection process is illustrated in detail in Algorithm
\ref{algo:fuzzchick:pick}.


Having selected the next test case, the main loop proceeds to execute it,
capturing both the result (passed, discarded, or failed) and its execution trace
over the system under test.
%
If the test case fails, it is immediately reported as a bug.
%
If not, \fuzzchick evaluates whether it was interesting (i.e., it exercises a
new path) based on its trace information and the one from previously executed
test cases (represented by \textit{TLog}).
%
If the test case does in fact discover a new path, it is enqueued at the end of
its corresponding queue, depending on whether it passed or was discarded.
%
This process alternates between generation and mutation until a bug is found or
we reach the test limit.


The energy assigned to each test case follows that of AFL's power schedule: more
energy to test cases that lead to shorter executions, or that discover more
parts of the code.
%
Moreover, to favour mutating interesting valid test cases, they get more energy
than those that were discarded.



\begin{figure}[t]
\begin{multicols}{2}

\begin{algorithm}[H]
  \SetArgSty{textnormal}
  \SetInd{0em}{0.75em}
  \SetKw{KwNot}{not}
  \SetAlgoLined
  \DontPrintSemicolon
  \SetKwFunction{FC}{Loop}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\FC{P, N, gen, mut}}{
    i $\gets$ 0\;
    TLog, QSucc, QDisc $\gets$ $\varnothing$;\;
    \While{i $<$ N}{
      x $\gets$ Pick(QSucc, QDisc, gen, mut)\;
      (result, trace) $\gets$ WithTrace(P(x))\;
      \lIf{\KwNot result}{\KwRet Bug(x)}
      \If{Interesting(TLog, trace)}{
        e $\gets$ Energy(TLog, x, trace)\;
        \eIf{\KwNot Discarded(result)}{
          Enqueue(QSucc, (x, e))\;
        }{
          Enqueue(QDisc, (x, e))\;
        }
      }
      i $\gets$ i+1\;
    }
    \KwRet Ok\;
  }
\caption{\label{algo:fuzzchick:loop}\fuzzchick Testing Loop}
\end{algorithm}

\columnbreak

\begin{algorithm}[H]
  \SetArgSty{textnormal}
  \SetInd{0em}{0.75em}
  \SetKw{KwNot}{not}
  \SetAlgoLined
  \DontPrintSemicolon
  \SetKwFunction{Pick}{Pick}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\Pick{QSucc, QDisc, gen, mut}}{
    \If{\KwNot Empty(QSucc)}{
      (x,e) $\gets$ Deque(QSucc)\;
      \If{e $>$ 0}{
        PushFront(QSucc, (x, e-1))
      }
      \KwRet Sample(mut(x))\;
    }
    \uElseIf{\KwNot Empty(QDisc)}{
      (x,e) $\gets$ Deque(QDisc)\;
      \If{e $>$ 0}{
        PushFront(QDisc, (x, e-1))
      }
      \KwRet Sample(mut(x))\;
    }
    \lElse{\KwRet Sample(gen)}
  }
\caption{\label{algo:fuzzchick:pick}\fuzzchick Seed Selection}
\end{algorithm}

\end{multicols}
\end{figure}

\subsubsection{Well-typed mutations}

Mutators in \fuzzchick are no more than specialized random generators,
parameterized by the original input to be mutated.
%
They use a simple set of mutation operations that are randomly applied at the
datatype level.
%
In simple terms, these operations encompass:
%
\begin{itemize}
\item \emph{shrinking the value}, replacing its top-level data constructor with
  one that contains a subset of its fields, reusing existing subexpressions;
\item \emph{growing the value}, replacing its top-level data constructor with
  one that contains a superset of its fields, reusing existing subexpressions
  and generating random ones when needed;
\item \emph{returning a subexpression of the same type};
\item \emph{mutating recursively}, applying a mutation operation over an
  immediate subexpression.
\end{itemize}


\begin{figure}
\begin{verbatim}
mutate_tree :: (a -> Gen a) -> Tree a -> Gen (Tree a)
mutate_tree mutate_a (Leaf x) =
  oneof [ do { x' <- mutate_a x; return (Leaf x')}                     -- Mutate recursively
        , do { l <- arbitrary; r <- arbitrary; return (Node l x r) } ] -- Grow constructor
mutate_tree (Node l x r) =
  oneof [ return l                                                     -- Return subexpression
        , return r                                                     -- Return subexpression
        , return (Leaf x)                                              -- Shrink constructor
        , do { l' <- mutate_tree l; return (Node l' x r) }             -- Mutate recursively
        , do { x' <- mutate_a    x; return (Node l x' r) }             -- Mutate recursively
        , do { r' <- mutate_tree r; return (Node l x r') } ]           -- Mutate recursively
\end{verbatim}
\caption{\label{fig:fuzzchick:mutator}\fuzzchick mutator for the \texttt{Tree} data type. }
\end{figure}

Fig. \ref{fig:fuzzchick:mutator} illustrates the idea behind a random \fuzzchick
mutator for our previously used \texttt{Tree} data type example.
%
Since trees are parametric, for clarity this definition is also parameterized by
a mutator for the payload (\texttt{mutate\_a}), although in practice this can be
abstracted away by the means of the type class system (where
\texttt{mutate\_tree} and \texttt{mutate\_a} can be transparently coerced into
an overloaded \texttt{mutate} function.)


In this mutator, branches can be shrinked into leaves by dropping the subtrees,
whereas leaves can grow into branches, by reusing the payload and generating two
random subtrees.
%
Moreover, branches can be replaced with one of their subtrees.
%
Finally, mutations can be recursively applied over both the payload and the
subtrees.
%
At the top level, all these operations are put together using the \texttt{oneof}
combinator that randomly picks one of them with uniform probability.

%
% FuzzChick Limitations
%
\subsubsection{Limitations of \fuzzchick}

\citeauthor{lampropoulos2019coverage} demonstrated empirically that \fuzzchick
lies comfortably in the middle ground between using na\"ive automatically
derived random generators and complex manually-written ones.
%
Their results suggest that CGPT is an appealing technique for finding bugs while
still offering a mostly automated workflow.

However, the authors acknowledge that certain parts of their implementation have
room for improvement, especially when it comes to the mutators design.
%
Moreover, when we recreated the evaluation of the IFC stack machine case study
(described in detail in Section \ref{sec:casestudies}), we found that after 30
runs (as opposed to the 5 runs used original by
\citeauthor{lampropoulos2019coverage}), \emph{\fuzzchick was only able to find 5
  out of the 20 injected bugs with a failure rate of 1}, the hardest one being
found only around 13\% of the time after an hour of testing.
%
These results are presented in detail in Section \ref{sec:evaluation}.


At the light of these observations, we identified several aspects of \fuzzchick
that can be improved upon --- and that constitute the main goal of this work.
%
In no particular order:
%
\begin{itemize}
\item \emph{Mutators distribution:} if we inspect the mutator defined in Fig.
  \ref{fig:fuzzchick:mutator}, there are two compromises that the authors of
  \fuzzchick adopted for the sake of simplicity.
  %
  On one hand, deep recursive mutations are very unlikely, since their
  probability decreases multiplicatively with each recursive call.
  %
  For instance, mutating a subexpression that lies on the third level of a
  \texttt{Tree} happens with a probability smaller than $(1/6)^3 = \sim 0.0046$,
  and this only worsens as the type of the mutated value becomes more complex.
  %
  Hence, \fuzzchick mutators can only be effectively used to transform to
  shallow data structures, potentially excluding interesting applications that
  might require producing deeper valid values, e.g., programming languages,
  network protocols interactions, etc.
  %
  Ideally, mutations should be able to happen on every subexpression of the
  input seed in a reasonable basis.

  On the other hand, using random generators to produce neeeded subexpressions
  when growing data constructors can be dangerous, as we are introducing the
  very same ``uncontrolled'' randomness that we wanted to mitigate in the first
  place!
  %
  If the random generator produces an invalid subexpression (something quite
  likely), this might just invalidate the whole mutated test case.
  %
  We believe that growing data constructors needs to be done carefully.
  %
  For instance, by using just a minimal piece of data to make the overall
  mutated test case type correct.
  %
  If that mutated test case to be interesting, that subexpression can always be
  mutated later.

\item \emph{Enqueuing mutation candidates:} \fuzzchick uses two single queues for
  keeping valid and discarded mutation candidates.
  %
  Whenever a new test case is found interesting, it is placed \emph{at the end
    of its corresponding queue}.
  %
  If this test case happens to have discovered a whole new portion of the target
  code, it will not be further mutated until the rest of the queue ahead of it
  gets processed.
  %
  This can limit the effectiveness of the testing loop if the queues tend to
  grow more often than they tend to shrink, as interesting mutation candidates
  can get buried at the end of a long queue that only exercises the same portion
  of the target code.
  %
  In the extreme case, they might not processed at all within the testing budget.
  %
  Ideally, one would like a mechanism that prioritizes mutating test cases
  that discovers new portions of the code right away, and that is capable of
  jumping back and forth from mutation candidates whenever this happens.
  %
  We show in Section \ref{sec:heuristics} how this can be achieved by analyzing
  the execution information in order to prioritize test cases with novel
  execution traces.


\item \emph{Power schedule:} It is not clear how the power schedule used to
  assign energy to each mutable test case in \fuzzchick works in the context of
  high-level well-typed mutations.
  %
  If it assigns too much energy to certain not-so-interesting seeds, some bugs
  might not be discovered in a timely basis.
  %
  Conversely, assigning too little energy to interesting test cases might cause
  that some bugs cannot be discovered at all unless the right mutation happens
  within the small available energy window --- randomly generating the same test
  case later on does not help, as it becomes uninteresting based on historic
  trace information.

  To keep the comparison fair, the authors replicated the same power schedule
  configuration used in AFL.
  %
  However, AFL uses a different mutation approach that works at the bit level.
  %
  This raises the question about what is the best power schedule configuration
  when using a high-level mutation approach --- something quite challenging to
  characterize in general given the expressivity of the data types used to
  drive the mutators.
\end{itemize}

The next section introduces \mutagen, our CGPT tool written in Haskell that aims
to tackle the main limitations of \fuzzchick using an exhaustive mutation
approach that requires very little randomness and no power schedule.

\section{\mutagen: Testing Mutants Exhaustively}
\label{sec:mutagen}

Aliquam erat volutpat \citep{devai2013edsl}. Nunc eleifend leo vitae magna. In
id erat non orci commodo lobortis. Proin neque massa, cursus ut, gravida ut,
lobortis eget, lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus.
Mauris ac felis vel velit tristique imperdiet.
nec dui dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a,
aliquet quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet
tortor. Nam euismod tellus id erat.

\begin{verbatim}
type Mutation a = a -> [Mutant a]
\end{verbatim}

\begin{verbatim}
data Mutant a = PURE a | RAND (Gen a)
\end{verbatim}

\begin{verbatim}
mutate (Leaf x)     = [ PURE (Node def x def) ]   -- Swap constructor
mutate (Node l x r) = [ PURE l, PURE r            -- Return subexpression
                      , PURE (Leaf x)             -- Swap constructor
                      , PURE (Node l x l)         -- Rearrange subexpressions
                      , PURE (Node r x r)         -- Rearrange subexpressions
                      , PURE (Node r x l) ]       -- Rearrange subexpressions
\end{verbatim}

\begin{verbatim}
positions (Leaf x)       = node [ (0, positions x) ]
positions (Branch l x r) = node [ (0, positions l), (1, positions x), (2, positions r) ]
\end{verbatim}

\begin{verbatim}
inside []        mut x              = mut x
inside (0 : pos) mut (Leaf x)       = [ Leaf x'       | x' <- inside pos mut x ]
inside (0 : pos) mut (Branch l x r) = [ Branch l' x r | l' <- inside pos mut l ]
inside (1 : pos) mut (Branch l x r) = [ Branch l x' r | x' <- inside pos mut x ]
inside (2 : pos) mut (Branch l x r) = [ Branch l x r' | r' <- inside pos mut r ]
\end{verbatim}


Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat.

\begin{figure}
\begin{multicols}{2}

\begin{algorithm}[H]
  \SetArgSty{textnormal}
  \SetInd{0em}{0.75em}
  \SetKw{KwNot}{not}
  \SetAlgoLined
  \DontPrintSemicolon
  \SetKwFunction{MG}{Loop}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\MG{P, N, R, gen, mut}}{
    i $\gets$ 0\;
    TLog, QSucc, QDisc $\gets$ $\varnothing$;\;
    \While{i $<$ N}{
      x $\gets$ Pick(QSucc, QDisc, gen, mut)\;
      (result, trace) $\gets$ WithTrace(P(x))\;
      \lIf{\KwNot result}{\KwRet Bug(x)}
      \If{Interesting(TLog, trace)}{
        \If{\KwNot Discarded(result)}{
          muts $\gets$ Mutants(x, mut, R)\;
          Enqueue(QSucc, muts)\;
        }
        \uElseIf{Passed(Parent(x))}{
          muts $\gets$ Mutants(x, mut, R)\;
          Enqueue(QDisc, muts)\;
        }
      }
      i $\gets$ i+1\;
    }
    \KwRet Ok\;
  }
\caption{\mutagen Testing Loop}
\end{algorithm}

\columnbreak

\begin{algorithm}[H]
  \SetArgSty{textnormal}
  \SetInd{0em}{0.75em}
  \SetKw{KwNot}{not}
  \SetAlgoLined
  \DontPrintSemicolon
  \SetKwFunction{Pick}{Pick}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\Pick{QSucc, QDisc, gen}}{
    \If{\KwNot Empty(QSucc)}{
      muts $\gets$ Deque(QSucc)\;
      \If{Empty(muts)}{
        Pick(QSucc, QDisc, gen)\;
      } \uElse{
        PushFront(QSucc, Rest(muts))\;
        \KwRet First(muts)\;
      }
    }
    \If{\KwNot Empty(QSucc)}{
      muts $\gets$ Deque(QSucc)\;
      \If{Empty(muts)}{
        Pick(QSucc, QDisc, gen)\;
      } \uElse{
        PushFront(QSucc, Rest(muts))\;
        \KwRet First(muts)\;
      }
    }
    \lElse{\KwRet Sample(gen)}
  }
\caption{\mutagen Seed Selection}
\end{algorithm}
\end{multicols}
\end{figure}

Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor
tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis
eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis
parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor.
Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum.
Nam vestibulum accumsan nisl.


\begin{figure}

\begin{algorithm}[H]
  \SetArgSty{textnormal}
  \SetInd{0em}{0.75em}
  \SetKw{KwNot}{not}
  \SetKw{KwIn}{in}
  \SetKwFor{KwRepeat}{repeat}{times}
  \SetAlgoLined
  \DontPrintSemicolon
  \SetKwFunction{Muts}{Mutants}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\Muts{x, mut, R}}{
    muts $\gets$ $\varnothing$\;
    \For{pos \KwIn Flatten(Positions(x))}{
      \For{mutant \KwIn Inside(pos, mut, x)}{
        \Switch{mutant}{
          \Case{PURE $\hat{x}$}{
            Enqueue($\hat{x}$, muts)\;
          }
          \Case{RAND gen}{
            \KwRepeat{R}{
              $\hat{x}$ $\gets$ Sample(gen)\;
              Enqueue($\hat{x}$, muts)\;
            }
          }
        }
      }
    }
    \KwRet muts\;
  }
\caption{Mutants Initialization}
\end{algorithm}

\end{figure}


\section{\mutagen Heuristics}
\label{sec:heuristics}

Pellentesque dapibus suscipit ligula. Donec posuere augue in quam. Etiam vel
tortor sodales tellus ultricies commodo. Suspendisse potenti. Aenean in sem ac
leo mollis blandit. Donec neque quam, dignissim in, mollis nec, sagittis eu,
wisi. Phasellus lacus. Etiam laoreet quam sed arcu. Phasellus at dui in ligula
mollis ultricies. Integer placerat tristique nisl. Praesent augue. Fusce
commodo.

\subsection{Priority FIFO Scheduling}

Vestibulum convallis, lorem a tempus semper, dui dui euismod elit,
vitae placerat urna tortor vitae lacus. Nullam libero mauris, consequat quis,
varius et, dictum id, arcu. Mauris mollis tincidunt felis. Aliquam feugiat
tellus ut neque. Nulla facilisis, risus a rhoncus fermentum, tellus tellus
lacinia purus, et dictum nunc justo sit amet elit.

\begin{figure}
\begin{multicols}{2}

\begin{algorithm}[H]
  \SetArgSty{textnormal}
  \SetInd{0em}{0.75em}
  \SetKw{KwNot}{not}
  \SetAlgoLined
  \DontPrintSemicolon
  \SetKwFunction{MG}{Loop}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\MG{P, N, R, gen, mut}}{
    $\cdots$\;
    (result, trace) $\gets$ WithTrace(P(x))\;
    $\cdots$\;
    \If{Interesting(TLog, trace)}{
      \If{\KwNot Discarded(result)}{
        muts $\gets$ Mutants(x, mut, R)\;
        {\color{red} prio $\gets$ BranchDepth(TLog, trace)}\; %% NEW
        {\color{red} PushFront(QSucc, prio, muts)}\;          %% NEW
      }
      $\cdots$\;
    }
  }
  \vspace{10pt}
  \SetKwFunction{Pick}{Pick}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\Pick{QSucc, QDisc, gen}}{
    \If{\KwNot Empty(QSucc)}{
      {\color{red} (muts, prio) $\gets$ DequeMin(QSucc)}\; %%NEW
      \If{Empty(muts)}{
        Pick(QSucc, QDisc, gen)\;
      } \uElse{
        {\color{red} PushFront(QSucc, prio, Rest(muts))}\; %% NEW
        \KwRet First(muts)\;
      }
    }
    $\cdots$\;
  }

\caption{Priority FIFO Heuristic}
\end{algorithm}

\columnbreak

\begin{algorithm}[H]
  \SetArgSty{textnormal}
  \SetInd{0em}{0.75em}
  \SetKw{KwNot}{not}
  \SetAlgoLined
  \DontPrintSemicolon
  \SetKwFunction{MG}{Loop}
  \SetKwProg{Fn}{Function}{:}{}
  \Fn{\MG{P, N, gen, mut}}{
    {\color{red}
    boring  $\gets$ 0\;
    reset   $\gets$ 1000\;
    R       $\gets$ 1\;
    }
    $\cdots$\;
    \While{i $<$ N}{
      {\color{red}
      \If{boring $>$ reset}{
        TLog   $\gets$ $\varnothing$\;
        reset $\gets$ reset * 2\;
        R     $\gets$ R * 2\;
      }
      }
      $\cdots$\;
      \lIf{\KwNot result}{\KwRet Bug(x)}
      \If{Interesting(TLog, trace)}{
        $\cdots$\;
      }
      \lElse {
        {\color{red} boring $\gets$ boring + 1}
      }
      $\cdots$\;
    }
  }

\caption{Trace Saturation Heuristic}
\end{algorithm}

\end{multicols}
\caption{\label{fig:heuristics} The two main heuristics implemented in \mutagen.
  Statements in {\color{red} red} indicate important changes to the base
  algorithm. Ellipses denote parts of the code that are not relevant for the
  point being made. }
\end{figure}


\subsection{Detecting Trace Space Saturation And Tuning Random Mutations}

Vestibulum convallis, lorem a tempus semper, dui dui euismod elit, vitae
placerat urna tortor vitae lacus. Nullam libero mauris, consequat quis, varius
et, dictum id, arcu. Mauris mollis tincidunt felis. Aliquam feugiat tellus ut
neque. Nulla facilisis, risus a rhoncus fermentum, tellus tellus lacinia purus,
et dictum nunc justo sit amet elit.

\subsection{Mutation Inheritance}

Vestibulum convallis, lorem a tempus semper, dui dui euismod elit,
vitae placerat urna tortor vitae lacus. Nullam libero mauris, consequat quis,
varius et, dictum id, arcu. Mauris mollis tincidunt felis. Aliquam feugiat
tellus ut neque. Nulla facilisis, risus a rhoncus fermentum, tellus tellus
lacinia purus, et dictum nunc justo sit amet elit.

\section{Case studies}
\label{sec:casestudies}

Aliquam erat volutpat \citep{devai2013edsl}. Nunc eleifend leo vitae magna. In id
erat non orci commodo lobortis. Proin neque massa, cursus ut, gravida ut,
lobortis eget, lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus.
Mauris ac felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque
nec dui dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a,
aliquet quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet
tortor. Nam euismod tellus id erat.

\subsection{IFC Stack Machine}

Pellentesque dapibus suscipit ligula. Donec posuere augue in quam. Etiam vel
tortor sodales tellus ultricies commodo. Suspendisse potenti. Aenean in sem ac
leo mollis blandit. Donec neque quam, dignissim in, mollis nec, sagittis eu,
wisi. Phasellus lacus. Etiam laoreet quam sed arcu. Phasellus at dui in ligula
mollis ultricies. Integer placerat tristique nisl. Praesent augue. Fusce
commodo. Vestibulum convallis, lorem a tempus semper, dui dui euismod elit,
vitae placerat urna tortor vitae lacus. Nullam libero mauris, consequat quis,
varius et, dictum id, arcu. Mauris mollis tincidunt felis. Aliquam feugiat
tellus ut neque. Nulla facilisis, risus a rhoncus fermentum, tellus tellus
lacinia purus, et dictum nunc justo sit amet elit.

\subsection{WebAssembly Engine}

Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec facilisis
facilisis, est dui fermentum leo, quis tempor ligula erat quis odio. Nunc porta
vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum. Aliquam posuere.
Nunc aliquet, augue nec adipiscing interdum, lacus tellus malesuada massa, quis
varius mi purus non odio. Pellentesque condimentum, magna ut suscipit hendrerit,
ipsum augue ornare nulla, non luctus diam neque sit amet urna. Curabitur
vulputate vestibulum lorem. Fusce sagittis, libero non molestie mollis, magna
orci ultrices dolor, at vulputate neque nulla lacinia eros. Sed id ligula quis
est convallis tempor. Curabitur lacinia pulvinar nibh. Nam a sapien.

\subsubsection{Testing the WebAssembly Validator}

Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec facilisis
facilisis, est dui fermentum leo, quis tempor ligula erat quis odio. Nunc porta
vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum. Aliquam posuere.
Nunc aliquet, augue nec adipiscing interdum, lacus tellus malesuada massa, quis
varius mi purus non odio. Pellentesque condimentum, magna ut suscipit hendrerit,
ipsum augue ornare nulla, non luctus diam neque sit amet urna. Curabitur
vulputate vestibulum lorem. Fusce sagittis, libero non molestie mollis, magna
orci ultrices dolor, at vulputate neque nulla lacinia eros. Sed id ligula quis
est convallis tempor. Curabitur lacinia pulvinar nibh. Nam a sapien.


\begin{verbatim}
prop_validator m =
  isValidHaskell m ==> isValidSpec m
\end{verbatim}

Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat.

\begin{verbatim}
isValidHaskell m =
  case validate m of
    Left  validationError -> return False
    Right validModule     -> return True
\end{verbatim}

Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat.

\begin{verbatim}
isValidSpec m = do
  writeFile "testcase.wasm" (dumpModule m)
  res <- shell "./wasm" ["-d", "-i", "testcase.wasm"]
  return (res == "")
\end{verbatim}

Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat.


\subsubsection{Testing the WebAssembly Interpreter}

Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat.


\begin{verbatim}
mk_module ty name fun =
  emptyModule { types     = [ ty ]
              , functions = [ fun ]
              , exports   = [ Export name (ExportFunc 0) ]
              , mems      = [ Memory (Limit 1 Nothing) ]
              }
\end{verbatim}

\begin{verbatim}
prop_interpreter ty (args, fun) =
  discardAfter 20
  (do let m = mk_module ty "f" fun;
      resHs   <- invokeHaskell m "f" args;
      resSpec <- invokeSpec    m "f" args;
      return (equiv resHs resSpec))
\end{verbatim}

\begin{verbatim}
prop_interpreter_i32 (i, f, fun) =
  prop_interpreter
    (FuncType { params = [I32, F32], result = [I32]})
    ([VI32 i, VF32 f], fun)
\end{verbatim}


\subsubsection{Real Bugs and Discrepancies found by \mutagen in \textit{haskell-wasm}}

\paragraph{Bug \#1: Invalid Memory Alignment Validation}
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor
tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis
eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis
parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor.
Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum.
Nam vestibulum accumsan nisl.

\paragraph{Bug \#2: Lax invocation checks}
Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat.


\paragraph{Bug \#3: Allowed Out-of-bounds Memory Access}
Pellentesque dapibus suscipit ligula. Donec posuere augue in quam. Etiam vel
tortor sodales tellus ultricies commodo. Suspendisse potenti. Aenean in sem ac
leo mollis blandit. Donec neque quam, dignissim in, mollis nec, sagittis eu,
wisi. Phasellus lacus. Etiam laoreet quam sed arcu. Phasellus at dui in ligula
mollis ultricies. Integer placerat tristique nisl. Praesent augue. Fusce
commodo. Vestibulum convallis, lorem a tempus semper, dui dui euismod elit,
vitae placerat urna tortor vitae lacus. Nullam libero mauris, consequat quis,
varius et, dictum id, arcu. Mauris mollis tincidunt felis. Aliquam feugiat
tellus ut neque. Nulla facilisis, risus a rhoncus fermentum, tellus tellus
lacinia purus, et dictum nunc justo sit amet elit.

\paragraph{Discrepancy \#1: Different Reinterpretation Semantics of NaN Values}
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor
tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis
eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis
parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor.
Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum.
Nam vestibulum accumsan nisl.

\paragraph{Discrepancy \#2: Allowed Blocks with Multiple Return Types}
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec hendrerit tempor
tellus. Donec pretium posuere tellus. Proin quam nisl, tincidunt et, mattis
eget, convallis nec, purus. Cum sociis natoque penatibus et magnis dis
parturient montes, nascetur ridiculus mus. Nulla posuere. Donec vitae dolor.
Nullam tristique diam non turpis. Cras placerat accumsan nulla. Nullam rutrum.
Nam vestibulum accumsan nisl.

\section{Evaluation}
\label{sec:evaluation}

\subsection{IFC Stack Machine}

Aliquam erat volutpat \citep{devai2013edsl}. Nunc eleifend leo vitae magna. In
id erat non orci commodo lobortis. Proin neque massa, cursus ut, gravida ut,
lobortis eget, lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus.
Mauris ac felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque
nec dui dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a,
aliquet quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet
tortor. Nam euismod tellus id erat.

\begin{center}
  \includegraphics[width=\linewidth]{tikz/ifc-mttf.tikz}
  \includegraphics[width=\linewidth]{tikz/ifc-fr.tikz}
\end{center}

\subsection{Webassembly Engine}

Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat.

\begin{center}
  \includegraphics[width=\linewidth]{tikz/wasm-mttf.tikz}
  \includegraphics[width=\linewidth]{tikz/wasm-fr.tikz}\vspace{-5pt}
  \includegraphics[width=\linewidth]{tikz/wasm-legend.tikz}
\end{center}

\section{Implementation}
\label{sec:implementation}

\subsection{Deriving Mutation Machinery}

Integer placerat tristique nisl. Praesent augue. Fusce commodo. Vestibulum
convallis, lorem a tempus semper, dui dui euismod elit, vitae placerat urna
tortor vitae lacus. Nullam libero mauris, consequat quis, varius et, dictum id,
arcu. Mauris mollis tincidunt felis. Aliquam feugiat tellus ut neque. Nulla
facilisis, risus a rhoncus fermentum, tellus tellus lacinia purus, et dictum
nunc justo sit amet elit.

\subsection{Tracing Haskell Programs}

\begin{verbatim}
  sorted []       = True
  sorted [x]      = True
  sorted (x:y:xs) = if x <= y then sorted (y:xs) else False
\end{verbatim}

\begin{verbatim}
  sorted []       = _trace_ 1 (True)
  sorted [x]      = _trace_ 2 (True)
  sorted (x:y:xs) = _trace_ 3 (if x <= y then _trace_ 4 (sorted (y:xs)) else _trace_ 5 (False))
\end{verbatim}

Pellentesque dapibus suscipit ligula. Donec posuere augue in quam. Etiam vel
tortor sodales tellus ultricies commodo. Suspendisse potenti. Aenean in sem ac
leo mollis blandit. Donec neque quam, dignissim in, mollis nec, sagittis eu,
wisi. Phasellus lacus. Etiam laoreet quam sed arcu. Phasellus at dui in ligula
mollis ultricies.

\section{Related work}
\label{sec:related}


\subsection{Grammar-based Fuzzing}

Pellentesque dapibus suscipit ligula. Donec posuere augue in quam. Etiam vel
tortor sodales tellus ultricies commodo. Suspendisse potenti. Aenean in sem ac
leo mollis blandit. Donec neque quam, dignissim in, mollis nec, sagittis eu,
wisi. Phasellus lacus. Etiam laoreet quam sed arcu. Phasellus at dui in ligula
mollis ultricies. Integer placerat tristique nisl. Praesent augue. Fusce
commodo. Vestibulum convallis, lorem a tempus semper, dui dui euismod elit,
vitae placerat urna tortor vitae lacus. Nullam libero mauris, consequat quis,
varius et, dictum id, arcu. Mauris mollis tincidunt felis. Aliquam feugiat
tellus ut neque. Nulla facilisis, risus a rhoncus fermentum, tellus tellus
lacinia purus, et dictum nunc justo sit amet elit.

\subsection{Random Data Generation}

%% Don't forget to cite "Deriving good generators ..."

Pellentesque dapibus suscipit ligula. Donec posuere augue in quam. Etiam vel
tortor sodales tellus ultricies commodo. Suspendisse potenti. Aenean in sem ac
leo mollis blandit. Donec neque quam, dignissim in, mollis nec, sagittis eu,
wisi. Phasellus lacus. Etiam laoreet quam sed arcu. Phasellus at dui in ligula
mollis ultricies. Integer placerat tristique nisl. Praesent augue. Fusce
commodo. Vestibulum convallis, lorem a tempus semper, dui dui euismod elit,
vitae placerat urna tortor vitae lacus. Nullam libero mauris, consequat quis,
varius et, dictum id, arcu. Mauris mollis tincidunt felis. Aliquam feugiat
tellus ut neque. Nulla facilisis, risus a rhoncus fermentum, tellus tellus
lacinia purus, et dictum nunc justo sit amet elit.

\subsection{Exhaustive Bounded Testing}

Aliquam erat volutpat \citep{devai2013edsl}. Nunc eleifend leo vitae magna. In id
erat non orci commodo lobortis. Proin neque massa, cursus ut, gravida ut,
lobortis eget, lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus.
Mauris ac felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque
nec dui dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a,
aliquet quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet
tortor. Nam euismod tellus id erat.

\section{Conclusions}
\label{sec:conclusions}

Aliquam erat volutpat \citep{devai2013edsl}. Nunc eleifend leo vitae magna. In id
erat non orci commodo lobortis. Proin neque massa, cursus ut, gravida ut,
lobortis eget, lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus.
Mauris ac felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque
nec dui dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a,
aliquet quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet
tortor. Nam euismod tellus id erat.

% ----------------------------------------

%% The acknowledgments section is defined using the "acks" environment (and NOT
%% an unnumbered section). This ensures the proper identification of the section
%% in the article metadata, and the consistent spelling of the heading.

%% \begin{acks}
%% To Robert, for the bagels and explaining CMYK and color spaces.
%% \end{acks}

% ----------------------------------------

%% The next two lines define the bibliography style to be used, and the
%% bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

% ----------------------------------------

%% If your work has an appendix, this is the place to put it.
\appendix

\section{Detailed Empirical Results}

Fusce suscipit, wisi nec facilisis facilisis, est dui fermentum leo, quis tempor
ligula erat quis odio. Nunc porta vulputate tellus. Nunc rutrum turpis sed pede.
Sed bibendum. Aliquam posuere. Nunc aliquet, augue nec adipiscing interdum,
lacus tellus malesuada massa, quis varius mi purus non odio. Pellentesque
condimentum, magna ut suscipit hendrerit, ipsum augue ornare nulla, non luctus
diam neque sit amet urna. Curabitur vulputate vestibulum lorem. Fusce sagittis,
libero non molestie mollis, magna orci ultrices dolor, at vulputate neque nulla
lacinia eros. Sed id ligula quis est convallis tempor. Curabitur lacinia
pulvinar nibh. Nam a sapien.

\end{document}
\endinput
%%
%% End of `main.tex'.
