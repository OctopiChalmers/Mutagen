{-# LANGUAGE RankNTypes #-}
module Test.Mutagen.Test.State where

import Data.PQueue.Prio.Min (MinPQueue)
import Data.Time.Clock.POSIX

import Test.QuickCheck.Gen (Gen)
import Test.QuickCheck.Random (QCGen, newQCGen)

import Test.Mutagen.Tracer
import Test.Mutagen.Property
import Test.Mutagen.Mutation
import Test.Mutagen.Fragment
import Test.Mutagen.Test.Config
import Test.Mutagen.Test.Batch

----------------------------------------
-- | Testing state (internal)

data State log
  = State
  ----------------------------------------
  -- Mirrored from Config
  { stMaxSuccess :: Int
  , stMaxDiscardRatio :: Int
  , stTimeout :: (Maybe Integer)
  , stMaxGenSize :: Int
  , stRandomMutations :: Int
  , stRandomFragments :: Int
  , stMutationLimit :: Int
  , stAutoResetAfter :: Maybe Int
  , stUseLazyPrunning :: Bool
  , stMutationOrder :: MutationOrder
  , stUseFragments :: Bool
  , stMaxTraceLength :: Maybe Int
  , stChatty :: Bool
  , stStepByStep :: Bool

  ----------------------------------------
  -- Test case generation
  , stNextSeed :: QCGen
  -- ^ The next seed to be used by `stArgsGen`
  , stArgsGen :: Gen Args
  -- ^ The random generator of inputs

  ----------------------------------------
  -- Property runner
  , stArgsRunner :: Args -> Result

  ----------------------------------------
  -- Trace logs
  , stGeneratedTraceNodes :: !Int
  , stPassedTraceLog :: !log
  , stDiscardedTraceLog :: !log

  ----------------------------------------
  -- Mutation queues
  , stPassedQueue :: !MutationQueue
  , stDiscardedQueue :: !MutationQueue

  ----------------------------------------
  -- Global fragment store
  , stFragmentStore :: !FragmentStore

  ----------------------------------------
  -- Statistics
  , stStartTime :: Integer
  , stCurrentGenSize :: Int
  , stNumGenerated :: !Int
  , stNumMutatedFromPassed :: !Int
  , stNumMutatedFromDiscarded :: !Int
  , stNumPassed :: !Int
  , stNumDiscarded :: !Int
  , stNumInteresting :: !Int
  , stNumBoring :: !Int
  , stNumTestsSinceLastInteresting :: !Int
  , stNumTraceLogResets :: !Int
  }

createInitialState :: forall log. TraceLogger log => Config -> Property -> IO (State log)
createInitialState cfg (Property gen argsRunner) = do
  -- rng generator
  rng <- newQCGen
  -- start timestamp
  now <- round <$> getPOSIXTime
  -- read the amount of trace nodes generated by the plugin
  traceNodes <- read <$> readFile ".tracer"
  -- create empty trace logs for passed and discarded test cases
  passedTraceLog <- emptyTraceLog traceNodes
  discardedTraceLog <- emptyTraceLog traceNodes
  -- fragmentize the initial example seeds
  let initialFragmentStore = foldr storeFragments emptyFragmentStore (examples cfg)
  -- build the initial state
  return State
    -- From config
    { stMaxSuccess = maxSuccess cfg
    , stMaxDiscardRatio = maxDiscardRatio cfg
    , stTimeout = timeout cfg
    , stMaxGenSize = maxGenSize cfg
    , stRandomMutations = randomMutations cfg
    , stRandomFragments = randomFragments cfg
    , stMutationLimit = maybe (2 ^ maxGenSize cfg) id (mutationLimit cfg)
    , stAutoResetAfter = autoResetAfter cfg
    , stUseLazyPrunning = useLazyPrunning cfg
    , stMutationOrder = mutationOrder cfg
    , stUseFragments = useFragments cfg
    , stMaxTraceLength = maxTraceLength cfg
    , stChatty = chatty cfg
    , stStepByStep = stepByStep cfg
    -- Internal
    , stNextSeed = rng
    , stArgsGen = gen
    , stArgsRunner = argsRunner
    , stGeneratedTraceNodes = traceNodes
    , stPassedTraceLog = passedTraceLog
    , stDiscardedTraceLog = discardedTraceLog
    , stPassedQueue = mempty
    , stDiscardedQueue = mempty
    , stFragmentStore = initialFragmentStore
    , stStartTime = now
    , stCurrentGenSize = 0
    , stNumGenerated = 0
    , stNumMutatedFromPassed = 0
    , stNumMutatedFromDiscarded = 0
    , stNumPassed = 0
    , stNumDiscarded = 0
    , stNumInteresting = 0
    , stNumBoring = 0
    , stNumTestsSinceLastInteresting = 0
    , stNumTraceLogResets = 0
    }

----------------------------------------
-- Mutation priority queues

-- Mutation candidates
type MutationQueue =
  MinPQueue
    Int                  -- The candidate priority
    ( Args               -- The test case inputs
    , Trace              -- The code coverage it triggered
    , MutationBatch Args -- The batch of possible mutations
    )

-- | Inherit the mutation batch of a parent test case of it exists, otherwise create a new one.
createOrInheritMutationBatch :: State log -> Args -> Maybe (MutationBatch Args) -> Maybe [Pos] -> Bool -> MutationBatch Args
createOrInheritMutationBatch st args parentbatch pos isPassed =
  case parentbatch of
    -- test case was mutated from an existing one, we can augment its parent mutation batch
    Just mb ->
      newMutationBatchFromParent mb
        pos isPassed args
    -- test case was freshly generated, we need to initialize a new mutation batch
    Nothing ->
      newMutationBatch
        (stMutationOrder st)
        (stRandomMutations st)
        (stMaxGenSize st)
        (stRandomFragments st)
        (stMutationLimit st)
        pos isPassed args

----------------------------------------
-- State-related utilities

-- | Check whether the timeout has passed
passedTimeout :: State log -> IO Bool
passedTimeout st
  | Just s <- stTimeout st = do
      now <- round <$> getPOSIXTime
      return (now >= stStartTime st + s)
  | otherwise = return False

computeSize :: State log -> Int
computeSize st
  | stNumPassed st `roundTo` stMaxGenSize st + stMaxGenSize st <= stMaxSuccess st
    || stNumPassed st >= stMaxSuccess st
    || stMaxSuccess st `mod` stMaxGenSize st == 0 =
    (stNumPassed st `mod` stMaxGenSize st + stNumDiscarded st `div` 10) `min` stMaxGenSize st
  | otherwise =
      ((stNumPassed st `mod` stMaxGenSize st) * stMaxGenSize st
       `div` (stMaxSuccess st `mod` stMaxGenSize st) + stNumDiscarded st `div` 10) `min` stMaxGenSize st

roundTo :: Integral a => a -> a -> a
roundTo n m = (n `div` m) * m

at0 :: (Int -> Int -> Int) -> Int -> Int -> Int -> Int
at0 _ s 0 0 = s
at0 f _ n d = f n d
